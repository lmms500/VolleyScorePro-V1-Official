SPEC: Lote 3 - Infraestrutura de Modos de Jogo Dinâmicos
Especificação Técnica Detalhada
Fases: 1, 2 e 3 do PRD
Foco: Fundação, Tipos e Validação

1. ARQUIVO: src/types/domain.ts
1.1 Adicionar Novos Types (após linha 14)
SEARCH:


export type TeamColor = string;
REPLACE:


export type TeamColor = string;

// --- DYNAMIC GAME MODE TYPES ---

export type GameModePreset =
  | 'indoor-6v6'
  | 'beach-4v4'
  | 'beach-2v2'
  | 'triples-3v3'
  | 'quads-5v5';

export interface CourtLayoutConfig {
  playersOnCourt: 2 | 3 | 4 | 5 | 6;
  benchLimit: number;
  gridRows: 1 | 2 | 3;
  gridCols: 2;
  /**
   * Zone numbers for visual display.
   * Index 0 = Server (Zone 1 always).
   * Length must match playersOnCourt.
   */
  zoneMap: number[];
  /**
   * Grid order for left-side team.
   * Maps grid visual positions to player array indices.
   * Use -1 for empty slots (odd player counts like 3, 5).
   */
  gridOrderLeft: number[];
  /**
   * Grid order for right-side team (mirrored).
   * Use -1 for empty slots.
   */
  gridOrderRight: number[];
}

export interface GameModeConfig {
  preset: GameModePreset;
  label: string;
  type: GameMode; // 'indoor' | 'beach' for backwards compatibility
  courtLayout: CourtLayoutConfig;
}
1.2 Atualizar GameConfig (após linha 41)
SEARCH:


export interface GameConfig {
  mode: GameMode;
  maxSets: 1 | 3 | 5;
REPLACE:


export interface GameConfig {
  mode: GameMode;
  /**
   * New: Full mode configuration object.
   * If undefined, derive from `mode` for backwards compatibility.
   */
  modeConfig?: GameModeConfig;
  maxSets: 1 | 3 | 5;
2. NOVO ARQUIVO: src/config/gameModes.ts
CREATE FILE:


/**
 * Game Mode Configuration Registry
 *
 * Central source of truth for all game mode presets.
 * Defines court limits, bench limits, and visual layout for each mode.
 */

import { GameModeConfig, GameModePreset, CourtLayoutConfig, GameMode } from '../types';

// ============================================
// COURT LAYOUT CONFIGURATIONS
// ============================================

const LAYOUT_6V6: CourtLayoutConfig = {
  playersOnCourt: 6,
  benchLimit: 6,
  gridRows: 3,
  gridCols: 2,
  zoneMap: [1, 6, 5, 4, 3, 2],
  gridOrderLeft: [2, 3, 1, 4, 0, 5],
  gridOrderRight: [5, 0, 4, 1, 3, 2],
};

const LAYOUT_5V5: CourtLayoutConfig = {
  playersOnCourt: 5,
  benchLimit: 4,
  gridRows: 3,
  gridCols: 2,
  zoneMap: [1, 5, 4, 3, 2],
  // One empty slot (-1) in each order
  gridOrderLeft: [2, 3, 1, 4, 0, -1],
  gridOrderRight: [-1, 0, 4, 1, 3, 2],
};

const LAYOUT_4V4: CourtLayoutConfig = {
  playersOnCourt: 4,
  benchLimit: 3,
  gridRows: 2,
  gridCols: 2,
  zoneMap: [1, 4, 3, 2],
  gridOrderLeft: [1, 2, 0, 3],
  gridOrderRight: [3, 0, 2, 1],
};

const LAYOUT_3V3: CourtLayoutConfig = {
  playersOnCourt: 3,
  benchLimit: 2,
  gridRows: 2,
  gridCols: 2,
  zoneMap: [1, 3, 2],
  // Triangle formation: one empty slot
  gridOrderLeft: [1, 2, 0, -1],
  gridOrderRight: [-1, 0, 2, 1],
};

const LAYOUT_2V2: CourtLayoutConfig = {
  playersOnCourt: 2,
  benchLimit: 1,
  gridRows: 1,
  gridCols: 2,
  zoneMap: [1, 2],
  gridOrderLeft: [0, 1],
  gridOrderRight: [1, 0],
};

// ============================================
// GAME MODE PRESETS
// ============================================

export const GAME_MODE_PRESETS: Record<GameModePreset, GameModeConfig> = {
  'indoor-6v6': {
    preset: 'indoor-6v6',
    label: 'Indoor 6v6',
    type: 'indoor',
    courtLayout: LAYOUT_6V6,
  },
  'quads-5v5': {
    preset: 'quads-5v5',
    label: 'Quads 5v5',
    type: 'indoor',
    courtLayout: LAYOUT_5V5,
  },
  'beach-4v4': {
    preset: 'beach-4v4',
    label: 'Beach 4v4',
    type: 'beach',
    courtLayout: LAYOUT_4V4,
  },
  'triples-3v3': {
    preset: 'triples-3v3',
    label: 'Triples 3v3',
    type: 'beach',
    courtLayout: LAYOUT_3V3,
  },
  'beach-2v2': {
    preset: 'beach-2v2',
    label: 'Beach Doubles 2v2',
    type: 'beach',
    courtLayout: LAYOUT_2V2,
  },
};

// ============================================
// HELPER FUNCTIONS
// ============================================

/**
 * Get full GameModeConfig based on mode and optional player count.
 * Provides backwards compatibility for states without modeConfig.
 *
 * @param mode - 'indoor' or 'beach'
 * @param playersOnCourt - Optional specific player count
 * @returns Full GameModeConfig object
 */
export function getGameModeConfig(
  mode: GameMode,
  playersOnCourt?: number
): GameModeConfig {
  // If specific player count provided, find matching preset
  if (playersOnCourt !== undefined) {
    const match = Object.values(GAME_MODE_PRESETS).find(
      p => p.courtLayout.playersOnCourt === playersOnCourt
    );
    if (match) return match;
  }

  // Default based on mode
  if (mode === 'beach') {
    return GAME_MODE_PRESETS['beach-4v4'];
  }

  // Default fallback: indoor 6v6
  return GAME_MODE_PRESETS['indoor-6v6'];
}

/**
 * Get court layout from GameConfig with backwards compatibility.
 * Use this when you need layout info from state.
 */
export function getCourtLayoutFromConfig(config: {
  mode: GameMode;
  modeConfig?: GameModeConfig
}): CourtLayoutConfig {
  if (config.modeConfig) {
    return config.modeConfig.courtLayout;
  }
  return getGameModeConfig(config.mode).courtLayout;
}

/**
 * Check if a grid order index is an empty slot.
 * Empty slots are represented by -1 in gridOrder arrays.
 */
export function isEmptySlot(gridOrderIndex: number): boolean {
  return gridOrderIndex === -1;
}

/**
 * Get the total grid slots (including empty) for a layout.
 */
export function getTotalGridSlots(layout: CourtLayoutConfig): number {
  return layout.gridRows * layout.gridCols;
}
3. ARQUIVO: src/constants.ts
3.1 Refatorar Helpers (linhas 42-50)
SEARCH:


// Helper to get court limit based on mode
export const getPlayersOnCourt = (mode: GameMode) => mode === 'beach' ? BEACH_COURT_LIMIT : INDOOR_COURT_LIMIT;

// Helper to get bench limit based on mode
export const getBenchLimit = (mode: GameMode) => mode === 'beach' ? BEACH_BENCH_LIMIT : INDOOR_BENCH_LIMIT;

// Legacy constant for backwards compatibility where mode isn't available (defaulting to max)
export const PLAYER_LIMIT_ON_COURT = 6;
export const PLAYERS_PER_TEAM = 6; // Max roster size logic (can be overridden by dynamic logic)
REPLACE:


// Helper to get court limit based on mode
// UPDATED: Now supports dynamic player counts via optional second parameter
export const getPlayersOnCourt = (mode: GameMode, playersOnCourt?: number): number => {
  if (playersOnCourt !== undefined) {
    return playersOnCourt;
  }
  return mode === 'beach' ? BEACH_COURT_LIMIT : INDOOR_COURT_LIMIT;
};

// Helper to get bench limit based on mode
// UPDATED: Now supports dynamic bench limits via optional second parameter
export const getBenchLimit = (mode: GameMode, benchLimit?: number): number => {
  if (benchLimit !== undefined) {
    return benchLimit;
  }
  return mode === 'beach' ? BEACH_BENCH_LIMIT : INDOOR_BENCH_LIMIT;
};

/**
 * @deprecated Use getGameModeConfig() from src/config/gameModes.ts instead
 * Legacy constant for backwards compatibility where mode isn't available
 */
export const PLAYER_LIMIT_ON_COURT = 6;

/**
 * @deprecated Use getGameModeConfig() from src/config/gameModes.ts instead
 * Max roster size logic (can be overridden by dynamic logic)
 */
export const PLAYERS_PER_TEAM = 6;
4. NOVO ARQUIVO: src/utils/validation.ts
CREATE FILE:


/**
 * Team and Match Validation Utilities
 *
 * Provides validation functions for dynamic game modes.
 * Use these before starting matches or making roster changes.
 */

import { Team, GameConfig, GameModeConfig, TeamId } from '../types';
import { getCourtLayoutFromConfig } from '../config/gameModes';

// ============================================
// TYPES
// ============================================

export interface TeamValidationResult {
  isValid: boolean;
  canStartMatch: boolean;
  playerCount: number;
  requiredPlayers: number;
  benchCount: number;
  benchLimit: number;
  warnings: string[];
  errors: string[];
}

export interface MatchValidationResult {
  canStart: boolean;
  teamAValidation: TeamValidationResult;
  teamBValidation: TeamValidationResult;
  reason?: string;
}

// ============================================
// TEAM VALIDATION
// ============================================

/**
 * Validate a team against the current game mode configuration.
 *
 * @param team - Team to validate
 * @param config - Current game configuration
 * @returns Detailed validation result
 */
export function validateTeamForMatch(
  team: Team,
  config: GameConfig
): TeamValidationResult {
  const layout = getCourtLayoutFromConfig(config);
  const { playersOnCourt, benchLimit } = layout;

  const playerCount = team.players.length;
  const benchCount = (team.reserves || []).length;

  const result: TeamValidationResult = {
    isValid: true,
    canStartMatch: false,
    playerCount,
    requiredPlayers: playersOnCourt,
    benchCount,
    benchLimit,
    warnings: [],
    errors: [],
  };

  // Check minimum players
  if (playerCount < playersOnCourt) {
    result.errors.push(
      `Faltam ${playersOnCourt - playerCount} jogadores. ` +
      `Necessário: ${playersOnCourt}, Atual: ${playerCount}`
    );
    result.isValid = false;
  }

  // Team can start if has minimum players
  if (playerCount >= playersOnCourt) {
    result.canStartMatch = true;
  }

  // Warn if over bench limit
  if (benchCount > benchLimit) {
    result.warnings.push(
      `Banco excede limite de ${benchLimit}. Atual: ${benchCount}`
    );
  }

  // Warn if no substitutes available
  if (playerCount === playersOnCourt && benchCount === 0) {
    result.warnings.push('Sem substitutos disponíveis no banco');
  }

  // Warn if team has too many players on court (shouldn't happen)
  if (playerCount > playersOnCourt) {
    result.warnings.push(
      `Time com ${playerCount} jogadores em quadra, ` +
      `máximo permitido: ${playersOnCourt}`
    );
  }

  return result;
}

/**
 * Validate if a match can start with the current teams.
 *
 * @param teamA - First team
 * @param teamB - Second team
 * @param config - Current game configuration
 * @returns Match validation result
 */
export function validateMatchStart(
  teamA: Team,
  teamB: Team,
  config: GameConfig
): MatchValidationResult {
  const teamAValidation = validateTeamForMatch(teamA, config);
  const teamBValidation = validateTeamForMatch(teamB, config);

  const result: MatchValidationResult = {
    canStart: true,
    teamAValidation,
    teamBValidation,
  };

  if (!teamAValidation.canStartMatch) {
    result.canStart = false;
    result.reason = `${teamA.name}: ${teamAValidation.errors.join(', ')}`;
  } else if (!teamBValidation.canStartMatch) {
    result.canStart = false;
    result.reason = `${teamB.name}: ${teamBValidation.errors.join(', ')}`;
  }

  return result;
}

/**
 * Check if a team is complete (has exactly the required players).
 *
 * @param team - Team to check
 * @param config - Current game configuration
 * @returns true if team has exactly playersOnCourt players
 */
export function isTeamComplete(team: Team, config: GameConfig): boolean {
  const layout = getCourtLayoutFromConfig(config);
  return team.players.length === layout.playersOnCourt;
}

/**
 * Check if a team's bench is full.
 *
 * @param team - Team to check
 * @param config - Current game configuration
 * @returns true if reserves have reached benchLimit
 */
export function isBenchFull(team: Team, config: GameConfig): boolean {
  const layout = getCourtLayoutFromConfig(config);
  return (team.reserves || []).length >= layout.benchLimit;
}

/**
 * Check if a team can accept more players on court.
 *
 * @param team - Team to check
 * @param config - Current game configuration
 * @returns true if team.players.length < playersOnCourt
 */
export function canAddToCourt(team: Team, config: GameConfig): boolean {
  const layout = getCourtLayoutFromConfig(config);
  return team.players.length < layout.playersOnCourt;
}

/**
 * Check if a team can accept more players on bench.
 *
 * @param team - Team to check
 * @param config - Current game configuration
 * @returns true if reserves.length < benchLimit
 */
export function canAddToBench(team: Team, config: GameConfig): boolean {
  const layout = getCourtLayoutFromConfig(config);
  return (team.reserves || []).length < layout.benchLimit;
}
5. ARQUIVO: src/utils/rosterLogic.ts
5.1 Remover BENCH_LIMIT Hardcoded (linha 8)
SEARCH:


import { sanitizeInput } from './security';

const BENCH_LIMIT = 6;
REPLACE:


import { sanitizeInput } from './security';
import { getCourtLayoutFromConfig } from '../config/gameModes';
import { GameConfig } from '../types';

// REMOVED: const BENCH_LIMIT = 6;
// Now using dynamic benchLimit from config
5.2 Atualizar Assinatura da Função handleAddPlayer
A função handleAddPlayer precisa receber o config para determinar o benchLimit dinâmico.

Nota: Esta é uma mudança de assinatura que afeta chamadores. A implementação exata depende de como handleAddPlayer é chamada no código. A alteração principal é:


// ANTES (linha ~95):
export const handleAddPlayer = (
  newPlayer: Player,
  targetId: string,
  courtA: Team,
  courtB: Team,
  queue: Team[],
  courtLimit: number
): { courtA: Team, courtB: Team, queue: Team[] } => {

// DEPOIS:
export const handleAddPlayer = (
  newPlayer: Player,
  targetId: string,
  courtA: Team,
  courtB: Team,
  queue: Team[],
  config: GameConfig // Substituir courtLimit por config completo
): { courtA: Team, courtB: Team, queue: Team[] } => {
  const layout = getCourtLayoutFromConfig(config);
  const courtLimit = layout.playersOnCourt;
  const benchLimit = layout.benchLimit;
5.3 Atualizar Uso de BENCH_LIMIT
SEARCH (linha ~119):


        if ((team.reserves || []).length < BENCH_LIMIT) {
REPLACE:


        if ((team.reserves || []).length < benchLimit) {
SEARCH (linha ~131):


        if ((team.reserves || []).length < BENCH_LIMIT) {
REPLACE:


        if ((team.reserves || []).length < benchLimit) {
6. Integração com GameContext
6.1 Como o Estado Global Receberá as Novas Informações
O GameConfig dentro de GameState agora pode conter modeConfig. Para backward compatibility:


// Em src/contexts/GameContext.tsx ou similar

// Ao carregar estado salvo (LOAD_STATE):
function migrateConfig(config: GameConfig): GameConfig {
  if (config.modeConfig) {
    return config; // Já migrado
  }

  // Migrar estado antigo
  const modeConfig = getGameModeConfig(config.mode);
  return {
    ...config,
    modeConfig,
  };
}

// Ao aplicar configurações (APPLY_SETTINGS):
function handleApplySettings(config: GameConfig, playersOnCourt?: number): GameConfig {
  const modeConfig = getGameModeConfig(config.mode, playersOnCourt);
  return {
    ...config,
    modeConfig,
  };
}
6.2 Uso nos Componentes

// Componentes que precisam do layout:
const { modeConfig } = useRoster(); // ou useScore()
const layout = modeConfig?.courtLayout || getGameModeConfig(config.mode).courtLayout;

// Verificar slot vazio no grid:
import { isEmptySlot } from '../config/gameModes';

{gridOrder.map((playerIndex, gridPos) => (
  isEmptySlot(playerIndex)
    ? <EmptySlot key={gridPos} />
    : <PlayerToken key={gridPos} player={players[playerIndex]} />
))}
7. Tratamento de Slots Vazios (-1)
7.1 Regra Geral
O valor -1 em gridOrderLeft ou gridOrderRight indica um slot vazio no grid visual. Isso ocorre em modos com número ímpar de jogadores (3v3, 5v5).

7.2 Implementação no VolleyballCourt

// Em VolleyballCourt.tsx

const renderPlayerSlot = (playerIndex: number, gridPosition: number) => {
  // CRITICAL: Check for empty slot
  if (playerIndex === -1) {
    // Render invisible placeholder to maintain grid structure
    return (
      <div
        key={`empty-${gridPosition}`}
        className="invisible"
        aria-hidden="true"
      />
    );
  }

  const player = players[playerIndex];
  if (!player) {
    // Safety: player doesn't exist (shouldn't happen)
    return <div key={`missing-${gridPosition}`} className="invisible" />;
  }

  return <DraggablePlayer key={player.id} player={player} index={playerIndex} ... />;
};

// No JSX:
<div className={`grid grid-cols-2 grid-rows-${gridRows} gap-2`}>
  {gridOrder.map((playerIndex, gridPos) => renderPlayerSlot(playerIndex, gridPos))}
</div>
7.3 Validação de Segurança

// Antes de acessar players[index]:
function safeGetPlayer(players: Player[], index: number): Player | null {
  if (index < 0 || index >= players.length) {
    return null;
  }
  return players[index];
}
8. Checklist de Implementação
Fase 1: Tipos e Config
 Adicionar types em src/types/domain.ts
 Criar src/config/gameModes.ts com presets
 Verificar exports em src/types/index.ts
Fase 2: Refatoração de Constants
 Atualizar src/constants.ts com novos helpers
 Marcar constantes legacy como @deprecated
 Testar backward compatibility
Fase 3: Validação e RosterLogic
 Criar src/utils/validation.ts
 Refatorar src/utils/rosterLogic.ts
 Atualizar chamadores de handleAddPlayer
 Testar fluxo de adição de jogadores
Verificação
 Build passa sem erros (npm run build)
 TypeScript compila (npx tsc --noEmit)
 Games antigos carregam corretamente
9. Ordem de Execução Recomendada
src/types/domain.ts - Base de tipos
src/config/gameModes.ts - Novo arquivo
src/utils/validation.ts - Novo arquivo
src/constants.ts - Refatoração
src/utils/rosterLogic.ts - Remoção de hardcode
Testes manuais - Verificar funcionamento